{"meta":{"title":"陈·述","subtitle":"江山一叶在扁舟、英雄无踪枉回首 --河西东","description":"technology and stuff","author":"Chen Bin","url":"http://chenbin9333.com"},"pages":[{"title":"about","date":"2016-04-10T06:14:34.000Z","updated":"2018-05-29T07:46:21.719Z","comments":true,"path":"about/index.html","permalink":"http://chenbin9333.com/about/index.html","excerpt":"","text":"编程、读书、写作、运动！ 河西东 关注编程、Java开发、小程序开发、移动应用开发、UI设计等 喜欢传统文化、戏剧形象、武术、书法、读书、画画、听音乐 运动：篮球、跑步 email: chenbin9333@foxmail.com &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;江山一叶在扁舟、英雄无踪枉回首&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;— 河西东"},{"title":"archive","date":"2016-04-16T07:32:13.000Z","updated":"2018-05-29T07:18:02.923Z","comments":true,"path":"archive/index.html","permalink":"http://chenbin9333.com/archive/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-04-16T07:32:13.000Z","updated":"2018-05-29T07:18:14.743Z","comments":false,"path":"categories/index.html","permalink":"http://chenbin9333.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-04-16T07:32:13.000Z","updated":"2018-05-29T07:18:22.951Z","comments":true,"path":"tags/index.html","permalink":"http://chenbin9333.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Patchca生成验证码在linux环境下的报错：Could not initialize class sun.awt.X11GraphicsEnvironment","slug":"Patchca生成验证码报错","date":"2018-05-29T02:12:57.000Z","updated":"2018-05-29T06:35:09.054Z","comments":true,"path":"2018/05/29/Patchca生成验证码报错/","link":"","permalink":"http://chenbin9333.com/2018/05/29/Patchca生成验证码报错/","excerpt":"使用Patchca库生成验证码时的报错问题场景在CentOS下部署了工程，工程登录页的验证码使用Patchca框架生成，运行之后报错，报错堆栈信息大致如下： ​","text":"使用Patchca库生成验证码时的报错问题场景在CentOS下部署了工程，工程登录页的验证码使用Patchca框架生成，运行之后报错，报错堆栈信息大致如下： ​ 1234567891011121314151617181920212223242526272829java.lang.NoClassDefFoundError: Could not initialize class sun.awt.X11GraphicsEnvironment java.lang.Class.forName0(Native Method) java.lang.Class.forName(Class.java:191) java.awt.GraphicsEnvironment.createGE(GraphicsEnvironment.java:102) java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment(GraphicsEnvironment.java:81) java.awt.image.BufferedImage.createGraphics(BufferedImage.java:1182) java.awt.image.BufferedImage.getGraphics(BufferedImage.java:1172) com.github.bingoohuang.patchca.background.SingleColorBackgroundFactory.fillBackground(SingleColorBackgroundFactory.java:47)com.github.bingoohuang.patchca.service.AbstractCaptchaService.getCaptcha(AbstractCaptchaService.java:109) com.github.bingoohuang.patchca.utils.encoder.EncoderHelper.getChallangeAndWriteImage(EncoderHelper.java:32)com.xxx.controller.login.VerificationCode.generateCode(VerificationCode.java:91) sun.reflect.GeneratedMethodAccessor244.invoke(Unknown Source) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) java.lang.reflect.Method.invoke(Method.java:606)org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221)org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137)org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110)org.springframework.web.servlet.mvc.method.annotation.CustomHandlerAdapter.invokeHandleMethod(CustomHandlerAdapter.java:801)org.springframework.web.servlet.mvc.method.annotation.CustomHandlerAdapter.handleInternal(CustomHandlerAdapter.java:730)org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:959) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:893) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:617) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:723) com.xxx.common.xxx.XxxFilter.doFilter(XxxFilter.java:48)org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:85) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 问题分析问题很显然是生成二维码图片填充背景时调用了sun.awt.X11GraphicsEnvironment，然后当前linux环境下使用的是Open JDK，据搜索得知该类存在于Sun JRE，因此无法初始化该类也是理所当然的。 Java中的awt部分由于证书原因无法开源，所以该类不存在于Open JDK，也将永远不存在。 问题解决在应用的启动参数中添加如下参数： 1-Djava.awt.headless=true 据SO上一位答主所言，声明这个参数，意味着把程序置于命令行模式（commandline mode）运行，并且并非可以解决所有应用的出现的这个问题。作为一个后端应用，仅仅是生成图片字节流传送到前端，而非一个有对UI图形界面的强依赖的应用来说应当是切实可行的，比如在我当前的场景下问题是成功得到了解决。当然，特殊事情特殊分析，终极的解决方案还是把当前依赖的类放到我们的类路径下，更简单的方式就是使用SUN JRE。 探索我们来看看更多相关的知识，上述问题的出现是程序试图运行XWindows的图形环境。而java.awt.headless=true表示程序启用headless模式，比如在系统缺少显示设备、硬件时，依据系统的计算能力模拟出某些图形属性。 什么是X Window？X Window system 是利用网络架构的图形界面软件，主要分为两部分X Server和X Client。 X Server为图行程序提供显示服务，并接受用户界面输入，把输入事件交给图行程序（可以是windows manager）处理，并能创建、映射、删除视窗以及在视窗中写和绘图。 X Client主要完成应用程序计算处理的部分，信息输入给回X Server。","categories":[],"tags":[{"name":"Patchca","slug":"Patchca","permalink":"http://chenbin9333.com/tags/Patchca/"},{"name":"验证码","slug":"验证码","permalink":"http://chenbin9333.com/tags/验证码/"},{"name":"X11GraphicsEnvironment","slug":"X11GraphicsEnvironment","permalink":"http://chenbin9333.com/tags/X11GraphicsEnvironment/"}]},{"title":"跨域访问CORS探究","slug":"跨域资源访问CORS探究","date":"2018-05-22T13:38:39.000Z","updated":"2018-05-29T06:08:34.017Z","comments":true,"path":"2018/05/22/跨域资源访问CORS探究/","link":"","permalink":"http://chenbin9333.com/2018/05/22/跨域资源访问CORS探究/","excerpt":"什么是跨域？跨域，简单地讲，就是一个Web应用（http://www.a.com）下的文档或脚本访问另一个Web应用（http://www.b.com）下的资源。任何两个应用所在域，只要存在协议、域名或端口任意一个不相同，即被认为访问是跨域的。","text":"什么是跨域？跨域，简单地讲，就是一个Web应用（http://www.a.com）下的文档或脚本访问另一个Web应用（http://www.b.com）下的资源。任何两个应用所在域，只要存在协议、域名或端口任意一个不相同，即被认为访问是跨域的。 为什么会出现跨域访问限制？由于浏览器同源策略，我们这里主要讨论XmlHttpRequest同源策略，XmlHttpRequest同源策略禁止XHR对象向不同源的服务器地址发送请求，这是浏览器出于安全考虑所做的限制。 使用ajax向另一个域下的应用发送一个请求，在服务端未做跨域相关的处理之前将报如下错误： 1Failed to load http://localhost:8081/api: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://localhost:3200&apos; is therefore not allowed access. If an opaque response serves your needs, set the request&apos;s mode to &apos;no-cors&apos; to fetch the resource with CORS disabled. 什么是CORS？CORS，全称Cross-Origin Resource Sharing，即跨域（源）资源共享。CORS使用目标服务器上返回的HTTP头信息来标识允许来自特定的域的跨域访问。跨域请求诸如标签加载来自不同域的图片、引用CDN的脚本样式等是允许的。然而为了安全考虑，浏览器显示了从脚本里发起的跨域HTTP请求，由于XMLHttpRequest和Fetch API遵从同源策略，在没有服务器端返回允许跨域的CORS头部信息时，这种类型的请求将被限制。 CORS机制保障了浏览器和服务器之间跨域请求和数据传输的安全性，使得XMLHttpRequest和Fetch API进行跨域访问有了可能。 两种类型的跨域请求简单请求 (Simple requests)简单请求是指当前跨域请求不触发“跨域中的的预检验”（即后面说到的预检请求），简单请求需要满足下面所有条件： 请求方法是GET、POST或HEAD三者之一 请求头部信息中仅允许出现以下列表的请求头 Accept Accept-Language Content-Language Content-Type，并且该值为application/x-www-form-urlencoded、multipart/form-data、text/plain三者之一 Last-Event-ID DPR Save-Data Viewport-Width Width XMLHttpRequestUpload对象在请求中没有注册事件监听 在请求中没有使用ReadableStream对象 简单请求的请求头和响应头示例： 预检请求 (Preflight requests)预检请求会在真正的请求之前发送一次预检的OPTIONS请求，先校验最终的请求是否可以安全发送。满足以下任一条件即是一个预检请求： 请求方法是PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH之一 请求头信息包含除了Accept、Accept-Language、Content-Language、Last-Event-ID、DPR、Save-Data、Viewport-Width、Width之外的任何头信息 请求头信息包含Content-Type，其值不为application/x-www-form-urlencoded、multipart/form-data、text/plain三者任何一个 在XMLHttpRequestUpload对象中使用事件监听 请求中使用了ReadableStream对象 预检请求示例，实际发生了两次请求，一次options检验请求，一次是实际获取数据的请求： CORS中使用到的关键响应头信息 Access-Control-Allow-Origin 该头部项的值可配置为通配符：*，表示允许来自任何域的跨域访问 也可指定具体的域，比如：http://domain.a.com 注：跨域请求中的请求头部信息中的Origin为请求所在域，与该响应头部值匹配即可完成跨域访问 Access-Control-Allow-Methods 该头部项指定了跨域请求中允许使用的请求方法，也可配置成通配符*，多个值用逗号分隔，如： 1Access-Control-Allow-Methods: GET, POST, OPTIONS, HEAD, PUT Access-Control-Allow-Headers 该头部项指定了跨域请求中允许使用的头部信息，由于请求中经常使用到的Content-Type不为application/x-www-form-urlencoded、multipart/form-data、text/plain时，请求将转为预检请求，通常地，需要将Content-Type、其他一些常用的头部和自定义的头部信息在此处指定，以便跨域访问正常完成 Access-Control-Allow-Credentials 当前端网页请求指定了withCredentials为true时，后端返回响应头中需要指定Access-Control-Allow-Credentials值为true，如果仅仅是前端网页在请求时指定withCredentials为true，那后端返回的结果将被浏览器忽略，从而请求无法完成。跨域请求默认不发送cookie，前端网页请求时，将withCredentials值设为true，表示允许发送cookie信息，当然也需要服务器明确许可。 1Access-Control-Allow-Credentials: true CORS解决跨域访问限制的实现如果想让我们的后端应用允许某些特定域的跨域请求，一般地，我们需要在拦截请求处对请求进行校验并对允许的跨域请求响应设置适当的响应头部信息。 典型地，项目中使用了Servlet统一拦截了请求，这个时候需要实现我们对应允许的请求方法，如doGet、doPost处理普通的GET/POST请求，doOptions处理预检请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AppServlet extends HttpServlet&#123; @Override public void init() throws ServletException&#123; super.init(); &#125; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123; doPost(request, response); &#125; @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123; String origin = request.getHeader(\"Origin\"); List&lt;String&gt; allowOrigins = CORSUtil.getAllowOrigins(); if(StringUtils.isNotBlank(origin) &amp;&amp; allowOrigins.contains(origin))&#123; // 校验当前域是允许跨域访问的域 response.setHeader(\"Access-Control-Allow-Origin\", origin); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); response.setHeader(\"Access-Control-Allow-Methods\", \"*\"); response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With\"); &#125; // compose your response here &#125; /** * 处理跨域中的OPTIONS预检请求，OPTIONS请求同样需要指定允许访问的域 */ @Override protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doOptions(req, resp); String origin = req.getHeader(\"Origin\"); if(StringUtils.isNotBlank(origin))&#123; resp.setStatus(HttpStatus.SC_NO_CONTENT); //允许预检请求跨域，此处让所有OPTIONS请求都能跨域，实际检验在post中进行 resp.setHeader(\"Access-Control-Allow-Origin\", origin); resp.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); resp.setHeader(\"Access-Control-Allow-Methods\", \"*\"); resp.setHeader(\"Access-Control-Allow-Headers\", \"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With\"); &#125; &#125;&#125; 或者使用过滤器Filter一站式处理所有类型的请求： 123456789101112131415161718192021222324252627public class CorsFilter implements Filter&#123; @Override public void init(FilterConfig filterConfig) throws ServletException&#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException&#123; String origin = request.getHeader(\"Origin\"); List&lt;String&gt; allowOrigins = CORSUtil.getAllowOrigins(); if(\"OPTIONS\".equalsIgnoreCase(request.getMethod) || (StringUtils.isNotBlank(origin) &amp;&amp; allowOrigins.contains(origin))&#123; // 当为options请求 或 当前域是允许跨域访问的域 都设置必要的 完成跨域访问的响应头部信息 response.setHeader(\"Access-Control-Allow-Origin\", origin); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); response.setHeader(\"Access-Control-Allow-Methods\", \"*\"); response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With\"); &#125; &#125; @Override public void destroy()&#123; &#125; &#125; web.xml配置： 12345678&lt;filter&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.filter.CorsFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;corsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 参考链接： http://developer.mozilla.org/en-US/docs/Web/HTTP/CORS http://www.ruanyifeng.com/blog/2016/04/cors.html","categories":[{"name":"Web","slug":"Web","permalink":"http://chenbin9333.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://chenbin9333.com/tags/Web/"},{"name":"跨域请求","slug":"跨域请求","permalink":"http://chenbin9333.com/tags/跨域请求/"}]},{"title":"Node.js、npm和一些前端知识解惑","slug":"Node-js、npm和一些前端知识解惑","date":"2018-03-12T08:56:03.000Z","updated":"2018-05-29T07:43:09.454Z","comments":true,"path":"2018/03/12/Node-js、npm和一些前端知识解惑/","link":"","permalink":"http://chenbin9333.com/2018/03/12/Node-js、npm和一些前端知识解惑/","excerpt":"对以往经历过原生App开发、当前主要做后端开发的我这样一个童鞋来说，不仅觉得Web前端布局繁杂，并且对其技术体系了解不深，人说当今是大前端时代，微信推出小程序后我也开始接触到相关的开发，现在很多开发框架也引入了数据绑定的概念，类似的如vue.js。一直以来对Node.js也有很多疑问，在此记录个解惑笔记。","text":"对以往经历过原生App开发、当前主要做后端开发的我这样一个童鞋来说，不仅觉得Web前端布局繁杂，并且对其技术体系了解不深，人说当今是大前端时代，微信推出小程序后我也开始接触到相关的开发，现在很多开发框架也引入了数据绑定的概念，类似的如vue.js。一直以来对Node.js也有很多疑问，在此记录个解惑笔记。 Node.js 和 npm 12[官网关于Node.js的描述]Node.js® is a JavaScript runtime built on Chrome&apos;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js&apos; package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 所以，Node.js是一个构建在谷歌V8引擎的js运行环境。Node.js的事件驱动、非阻塞IO模型使其轻量、高效。npm是Node.js的包管理系统，是全世界最大的开发库生态系统。 下面引入一段RUNOOB网站上的解释： 1234NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：1. 允许用户从NPM服务器下载别人编写的第三方包到本地使用。2. 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。3. 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 从包管理的角度上来看，npm应该算是类似iOS中的CocoaPods，Java中的Maven。这样看起来就好理解多了。详细使用和原理还待深究。 随着各种Web应用的发展，HTML5、小程序、React Native各种技术在多个领域的广泛使用，逐渐引领了一股前端热潮。手机端利用React开发跨平台应用，Node.js可编写提供后端服务等等。 从当前Web前端开发来看，主要的前端技术框架有React、Angular JS、Vue，也有使用dva的，dva这个框架也是最近了解到的，可在github上找到。dva on github 常用的前端构建工具有Webpack、Gulp、Grunt。 ​","categories":[],"tags":[{"name":"frontend","slug":"frontend","permalink":"http://chenbin9333.com/tags/frontend/"}]},{"title":"JavaScript基础总结","slug":"JavaScript基础总结","date":"2018-02-27T08:27:00.000Z","updated":"2018-05-29T05:53:20.055Z","comments":true,"path":"2018/02/27/JavaScript基础总结/","link":"","permalink":"http://chenbin9333.com/2018/02/27/JavaScript基础总结/","excerpt":"JavaScript变量作用域作用域 代码块（Block）的概念 代码块的概念在不同的语言里可能有不同的含义，如Objective-C中的代码块就和此处的不同，这里是讲JavaScript中由花括号{}包裹的部分，称它为代码块，一般地，代码块中声明的变量叫做局部变量，这里局部的概念就引出了作用域。每个代码块都有一个自己的作用域，作用域限制了变量能否被访问。","text":"JavaScript变量作用域作用域 代码块（Block）的概念 代码块的概念在不同的语言里可能有不同的含义，如Objective-C中的代码块就和此处的不同，这里是讲JavaScript中由花括号{}包裹的部分，称它为代码块，一般地，代码块中声明的变量叫做局部变量，这里局部的概念就引出了作用域。每个代码块都有一个自己的作用域，作用域限制了变量能否被访问。 123456789for (var i = 0; i &lt; length; i++) &#123; // 此&#123;&#125;之间包含的代码可认为一个代码块&#125;if (isLogin) &#123; // 此&#123;&#125;之间包含的代码可认为一个代码块&#125;// ... and so on 顶级作用域 在最上层没有任何{}包裹的作用域为顶层作用域，声明的变量是哪里都可以访问的 1234567891011var global_v = 1; // 顶级作用域中声明的变量if (true) &#123; global_v = 2; // 子作用域中可写&#125;function alertVariable() &#123; alert(global_v); // 子作用域中可读&#125;alertVariable(); 块级作用域指某个{}之间包含的代码变量作用域，js中允许跨作用域访问变量，但这将导致混乱并提高bug发生率，应避免这么做。ES6中使用let关键字声明变量就将遵守块级作用域了。 12345678910111213/*** 块级作用域 ***/if (true) &#123; var local_v = 3; alert(&quot;local_v in block:&quot; + local_v);&#125;alert(&quot;local_v out of block:&quot; + local_v); // js语言中允许这样的访问，这种做法容易导致混乱，杜绝这种做法function accessOtherBlockLoaclVariable() &#123; // js语言中允许这样的访问，这种做法容易导致混乱，杜绝这种做法 alert(&quot;accessing other block local variable : &quot; + local_v); &#125;accessOtherBlockLoaclVariable(); 父子作用域子作用域可以访问父作用域的变量，但是父作用域无法访问子作用域的变量 123456789if(true)&#123; let parent_v = 5; if(parent_v &gt; 0)&#123; let child_v = &quot;a&quot;; // 使用let关键字，将遵循块级作用域 console.log(child_v); // 可以访问 parent_v = 6; // 也可以访问 &#125; console.log(child_v); //无法访问，报异常： Uncaught ReferenceError: y is not defined&#125; 作用域中覆盖的概念 当子作用域有变量与父作用域重名的时候，在子作用域里只能访问到子作用域的变量。称之为 覆盖。 子作用域的覆盖不会消除父作用域的变量。 1234567891011var x = 5;function a(x)&#123; if(x &gt; 0)&#123; x++; &#125; console.log(x);&#125;a(1);console.log(x); // 结果输出5，子作用域的覆盖不会消除父作用域的变量 好消息这一切都将成为过去，ES6中的const和let将是替代var变量命名的最佳实践。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chenbin9333.com/tags/JavaScript/"}]},{"title":"MacOS X 安装Mercurial","slug":"MacOS-X-安装Mercurial","date":"2018-02-22T08:22:00.000Z","updated":"2018-05-29T06:34:41.632Z","comments":true,"path":"2018/02/22/MacOS-X-安装Mercurial/","link":"","permalink":"http://chenbin9333.com/2018/02/22/MacOS-X-安装Mercurial/","excerpt":"Mercurial以下是来自Mercurial官网的介绍1Mercurial is a free, distributed source control management tool. It efficiently handles projects of any size and offers an easy and intuitive interface. Mercurial和当前广泛应用的git和svn都是源码版本管理工具。","text":"Mercurial以下是来自Mercurial官网的介绍1Mercurial is a free, distributed source control management tool. It efficiently handles projects of any size and offers an easy and intuitive interface. Mercurial和当前广泛应用的git和svn都是源码版本管理工具。 Mercurial 是python编写的，安装前需要先安装好 python 检查python是否安装 python --version，以下是我使用的版本 1Python 2.7.10 Mercurial 官网下载得到 mercurial-4.5 软件包 解压到合适的目录 进入主目录 cd mercurial-4.5 make install 进行安装 安装过程中可能出现 docutils 模块缺失abort: couldn’t generate documentation: docutils module is missing 从 http://docutils.sourceforge.net/ 下载docutils docutils的安装 tar -zxf docutils-0.14.tar.gz cd docutils-0.14 sudo python setup.py install 重新 make install 安装Mercurialhg debuginstall 检查安装情况1234567891011121314151617181920checking encoding (UTF-8)...checking Python executable (/usr/bin/python)checking Python version (2.7.10)checking Python lib (/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7)...checking Python security support (sni,tls1.0,tls1.1,tls1.2)checking Mercurial version (4.5)checking Mercurial custom build ()checking module policy (c)checking installed modules (/usr/local/lib/python2.7/site-packages/mercurial)...checking registered compression engines (bz2, bz2truncated, none, zlib, zstd)checking available compression engines (bz2, bz2truncated, none, zlib, zstd)checking available compression engines for wire protocol (zstd, zlib, bz2, none)checking &quot;re2&quot; regexp engine (missing)checking templates (/usr/local/lib/python2.7/site-packages/mercurial/templates)...checking default template (/usr/local/lib/python2.7/site-packages/mercurial/templates/map-cmdline.default)checking commit editor... (vi)checking username... no username supplied (specify a username in your configuration file)1 problems detected, please check your install! hg 查看hg命令帮助1234567891011121314151617181920212223Mercurial Distributed SCMbasic commands: add add the specified files on the next commit annotate show changeset information by line for each file clone make a copy of an existing repository commit commit the specified files or all outstanding changes diff diff repository (or selected files) export dump the header and diffs for one or more changesets forget forget the specified files on the next commit init create a new repository in the given directory log show revision history of entire repository or files merge merge another revision into working directory pull pull changes from the specified source push push changes to the specified destination remove remove the specified files on the next commit serve start stand-alone webserver status show changed files in the working directory summary summarize working directory state update update working directory (or switch revisions)(use &apos;hg help&apos; for the full list of commands or &apos;hg -v&apos; for details) 来自官网的快速上手，使用hg命令clone一把官网提供的hello repohg clone https://www.mercurial-scm.org/repo/hello 123456789destination directory: hellorequesting all changesadding changesetsadding manifestsadding file changesadded 2 changesets with 2 changes to 2 filesnew changesets 0a04b987be5a:82e55d328c8cupdating to branch default2 files updated, 0 files merged, 0 files removed, 0 files unresolved Everything is fine and now you are good to go!","categories":[],"tags":[{"name":"installation","slug":"installation","permalink":"http://chenbin9333.com/tags/installation/"}]},{"title":"工厂模式","slug":"工厂模式","date":"2018-02-22T02:54:04.000Z","updated":"2018-05-28T10:07:26.582Z","comments":true,"path":"2018/02/22/工厂模式/","link":"","permalink":"http://chenbin9333.com/2018/02/22/工厂模式/","excerpt":"对扩展友好，松耦合类型切换， 种类：简单工厂，抽象工厂，静态工厂方法","text":"对扩展友好，松耦合类型切换， 种类：简单工厂，抽象工厂，静态工厂方法","categories":[],"tags":[]},{"title":"Dubbo and ZooKepper","slug":"Dubbo-and-ZooKepper","date":"2016-12-07T01:31:33.000Z","updated":"2018-05-28T10:06:49.253Z","comments":true,"path":"2016/12/07/Dubbo-and-ZooKepper/","link":"","permalink":"http://chenbin9333.com/2016/12/07/Dubbo-and-ZooKepper/","excerpt":"1Writing is pretty much like coding, and the author is the compiler. Dubbo 和 ZooKeeper，一个“搭布”和动物园管理员的故事，而实际上它们是一个开发的故事，让我们开始学习并使用它们吧。 分而治之 (Divide and conquer.) 首先我们先解决何为 Dubbo 和 何为 ZooKeeper 的问题，再接着探究二者之间的关系，最后，再使用这两者进行开发应用实现一个Demo。","text":"1Writing is pretty much like coding, and the author is the compiler. Dubbo 和 ZooKeeper，一个“搭布”和动物园管理员的故事，而实际上它们是一个开发的故事，让我们开始学习并使用它们吧。 分而治之 (Divide and conquer.) 首先我们先解决何为 Dubbo 和 何为 ZooKeeper 的问题，再接着探究二者之间的关系，最后，再使用这两者进行开发应用实现一个Demo。 何为 Dubbo ？Dubbo 是阿里的一个开源框架，来看看 Dubbo 官网 给出的定义： 12345Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。其核心部分包含:* 远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。* 集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。* 自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 其中分布式是我们可以利用 Dubbo 进行集群搭建和负载均衡。而服务是服务提供方开发服务注册到注册中心提供给服务消费方使用，为远程服务，地址透明。 何为 ZooKeeper ？同样来看 ZooKeeper 官网 的定义： ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them ,which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed. ZooKeeper aims at distilling the essence of these different services into a very simple interface to a centralized coordination service. The service itself is distributed and highly reliable. Consensus, group management, and presence protocols will be implemented by the service so that the applications do not need to implement them on their own. Application specific uses of these will consist of a mixture of specific components of Zoo Keeper and application specific conventions. ZooKeeper Recipes shows how this simple service can be used to build much more powerful abstractions. 简单地翻译下，ZooKeeper 是一个维护配置信息、命名服务，提供分布式同步和集群服务的中心化的服务。这几种服务都被分布式应用中以某种形式被使用。由于实现这几种服务的难度，应用初期会略过它们，这就让它们（命名、分布式、集群服务等）在变化出现时非常脆弱且难于管理，所以每次去实现它们的时候都要花费大量时间处理bug和混乱的情况。即时我们正确实现了这些服务，但是应用部署的时候也会变得难以管理。 因此，ZooKeeper旨在作为一个分布式和高可用的中心协调调度服务，提取不同服务的精华成为一个简单的接口。集群管理、在线协议可以通过这个服务实现。应用对服务的具体使用将组成ZooKeeper的具体组件和应用的约定。ZooKeeper展示出了如何使用这个简单服务区构建更强大的抽象。 ZooKeeper 是作为Dubbo服务的注册中心使用，从设计模式角度看，是一个基于观察者模式设计的分布式服务管理框架。 Dubbo 和 ZooKeeper 的关系？Dubbo对注册中心进行了抽象，引入ZooKeeper作为Dubbo服务注册中心，ZooKeeper集群具备了负载均衡的能力，加上资源同步，使注册中心的承载能力增强。 （以上都是Dubbo和ZooKeeper的简单概述，而关于二者的原理和架构设计还需另做深究。） Dubbo 和 ZooKeeper 使用示例前提下载安装ZooKeeperZooKeeper 官网下载链接下载后解压即可使用了。 ZooKeeper启动、关闭进入ZooKeeper所在目录，进入其下层bin目录，使用命令操作ZooKeeper的开关。如zookeeper-3.4.6/bin： 启动服务: sh zkServer.sh start 查看服务状态: sh zkServer.sh status 停止服务: sh zkServer.sh stop 重启服务: sh zkServer.sh restart 示例编写编写提供者（Provider）提供的服务接口123public interface HelloService &#123; public String sayHello(String name);&#125; 服务接口的具体实现12345678public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;Hello &quot; + name; &#125;&#125; 注册并暴露服务接口提供者方的配置： 12&lt;!-- 需要暴露的服务实现类 --&gt; &lt;bean id=&quot;helloService&quot; class=&quot;com.delonix.service.provider.HelloServiceImpl&quot; /&gt; 12&lt;!-- 注册服务 --&gt; &lt;dubbo:service interface=&quot;com.delonix.service.HelloService&quot; ref=&quot;helloService&quot; /&gt; 消费者方的配置： 12&lt;!-- 订阅需要消费的服务 --&gt;&lt;dubbo:reference id=&quot;comsumerHelloService&quot; interface=&quot;com.delonix.service.HelloService&quot; /&gt; 客户端调用HelloService接口123456789101112131415161718@Controller@RequestMapping(&quot;/hello/*&quot;)public class HelloController &#123; @Autowired private HelloService comsumerHelloService; @RequestMapping(value=&quot;/sayHello&quot;, method=RequestMethod.GET) public void sayHello(@RequestParam(value=&quot;name&quot;, required=true) String name, HttpServletResponse resp) &#123; try &#123; String hello = comsumerHelloService.sayHello(name); // 执行远程方法 resp.getWriter().print(hello); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;a href=&quot;hello/sayHello?name=chenbin&quot;&gt;Hello Chenbin&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 页面执行结果将打印出：Hello chenbin 完整的Demo工程见Github链接https://github.com/chenbin9333/delonix","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://chenbin9333.com/tags/Java/"}]},{"title":"单例模式 Singleton Pattern","slug":"单例模式-Singleton-Pattern","date":"2016-04-11T15:04:36.000Z","updated":"2018-05-28T10:07:19.587Z","comments":true,"path":"2016/04/11/单例模式-Singleton-Pattern/","link":"","permalink":"http://chenbin9333.com/2016/04/11/单例模式-Singleton-Pattern/","excerpt":"何为单例模式？单例，顾名思义即为单个实例。我们使用单例模式的目标就是为了创建某个类的唯一实例，换个角度说就是保持某个类只有唯一一个实例存在并提供给外部使用。","text":"何为单例模式？单例，顾名思义即为单个实例。我们使用单例模式的目标就是为了创建某个类的唯一实例，换个角度说就是保持某个类只有唯一一个实例存在并提供给外部使用。 单例模式的定义《Head First Design Pattern》书中的定义：The Singleton Pattern ensures a class has only one instance, and provides a global point of access to it.单例模式保证某个类只有一个实例，并对外提供一个该实例的全局访问点。 单例模式应用场景有一些特殊的场景下我们需要保持类只有唯一实例以达到保持程序的正确性、避免资源过度使用、数据不一致等目的，比如线程池、缓存、对话框、用于保存一些偏好设置的对象等。 举个栗子，皇帝自古以来只有一个，试想当出现了多个皇帝，大家都不知道该认准哪一个，势必天下大乱。 实现单例模式的方式对于资源敏感型应用，可以采用懒加载方式，即在需要使用的时候才去创建这个唯一对象。实现单例的时候还要考虑的是多线程的问题。 Java中实现单例模式 私有化构造器 提供外部一个统一获取实例的方法 方案一：最简单的实现，没有考虑多线程问题，可能导致多个实例存在123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Singleton &#123; private static Singleton uniqueInstance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125; public static void main(String[] args) &#123; GetInstanceRunnable getInstanceRunnable = new GetInstanceRunnable(); Thread thread1 = new Thread(getInstanceRunnable); Thread thread2 = new Thread(getInstanceRunnable); Thread thread3 = new Thread(getInstanceRunnable); Thread thread4 = new Thread(getInstanceRunnable); Thread thread5 = new Thread(getInstanceRunnable); thread1.start(); thread2.start(); thread3.start(); thread4.start(); thread5.start(); &#125; private static class GetInstanceRunnable implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Singleton singleton = Singleton.getInstance(); System.out.println(singleton); &#125; &#125;&#125; 执行结果的可能性之一12345Singleton@4e2c390cSingleton@39556aecSingleton@4e2c390cSingleton@4e2c390cSingleton@4e2c390c 结果分析在不同的线程中去获取实例的时候，某一个线程获取实例时另一个正在初始化实例但尚未完成，导致重复执行实例化的代码，从而会有多个实例的Singleton存在。 方案二：使用同步锁对初始化实例进行锁定，以解决多线程中出现的问题123456public static synchronized Singleton getInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125; 结果分析虽然上面这种实现解决了多线程中出现多个实例的问题，但是使用同步锁的成本太大，并且同步锁只在第一次获取实例的时候才需要用到，只要实例化工作完成，后续将不再用到。 方案三：改进使用同步锁的方式123456789101112private static volatile Singleton uniqueInstance;public static Singleton getInstance() &#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125; 结果分析使用volatile关键字修饰uniqueInstance保证了多线程之间能正确处理它，即确保了uniqueInstance变量的更新操作能及时反应到其他线程之中，但volatile并不能完全保证线程安全，接着使用这个双重检查锁定的方式，达到只在第一次初始化时进行锁定，从而提高程序性能。双重检查锁定的方式只有在JDK 1.5之后才能达到单例的目的。 方案四：不使用懒加载的方式1234567public class Singleton &#123; private static Singleton uniqueInstance = new SingleTon(); public static Singleton getInstance() &#123; return uniqueInstance; &#125;&#125; 结果分析通过这种方式我们依赖于JVM在类加载完成后去创建一个唯一实例，JVM保证实例创建之前所有线程都无法访问到静态变量uniqueInstance。 方案五：依赖于Java的类加载机制实现单例模式1234567891011public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton uniqueInstance = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.uniqueInstance; &#125; &#125; 结果分析这种实现方式同样利用了Java的类加载机制来保证初始化时只有一个线程访问，而且使用类静态内部类来持有单例实例变量，从而达到懒加载的目的，如果没有调用getInstance()方法将不会对单例实例进行初始化。 总结需要保证线程安全并且使用懒加载的方式，我们可以采用方案三和方案五。而方案四也保证了线程安全，唯一的区别在于没有使用懒加载。这三种方式都是较好的实现方式。在Java中而言，使用方案五，避免了去处理很多相关的问题，由JVM帮我们一手包办，最直接简洁。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://chenbin9333.com/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://chenbin9333.com/tags/Design-Pattern/"},{"name":"设计模式","slug":"设计模式","permalink":"http://chenbin9333.com/tags/设计模式/"},{"name":"Singleton","slug":"Singleton","permalink":"http://chenbin9333.com/tags/Singleton/"},{"name":"单例模式","slug":"单例模式","permalink":"http://chenbin9333.com/tags/单例模式/"}]}]}